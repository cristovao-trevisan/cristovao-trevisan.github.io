import { n as noop, s as safe_not_equal, S as SvelteComponent, i as init, e as empty, a as insert, g as group_outros, o as on_outro, c as check_outros, d as detach$1, b as subscribe, m as mount_component, f as get_spread_update, h as handle_promise, j as assign, k as create_slot, l as element, p as claim_element, q as children, r as listen, t as append, u as get_slot_changes, v as get_slot_context, w as createEventDispatcher, x as space, y as claim_text, z as text, A as attr, B as toggle_class, C as update_keyed_each, D as outro_and_destroy_block, E as set_data, F as setContext } from './chunk.1a0f83e2.js';
import { M as MenuIcon, m as menuRoutes } from './chunk.ac4dc9d7.js';

/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe,
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (!stop) {
                return; // not ready
            }
            subscribers.forEach((s) => s[1]());
            subscribers.forEach((s) => s[0](value));
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
            }
        };
    }
    return { set, update, subscribe };
}

const CONTEXT_KEY = {};

const preload = () => ({});

/* node_modules/svelte-loadable/Loadable.svelte generated by Svelte v3.4.4 */

const debounce = (time, call) => {
  let timeout = null;
  return () => {
    if (timeout) return
    timeout = setTimeout(() => {
      timeout = null;
      call();
    }, time);
  }
};

// @ts-check

const getDimensions = () => {
  // ssr default values
  if (typeof window === 'undefined') return { width: 800, height: 600 }

  const width = window.innerWidth
    || document.documentElement.clientWidth
    || document.body.clientWidth;
  const height = window.innerHeight
    || document.documentElement.clientHeight
    || document.body.clientHeight;
  return { width, height }
};

var dimensions = readable(getDimensions(), (set) => {
  if (typeof window === 'undefined') return // ssr

  const onChange = debounce(200, () => set(getDimensions()));
  window.addEventListener('resize', onChange, false);
  return () => window.removeEventListener('resize', onChange, false)
});

/* src/components/DimensionAware.svelte generated by Svelte v3.4.4 */

// (31:0) {:else}
function create_else_block(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		ctx.props
	];

	var switch_value = ctx.Default;

	function switch_props(ctx) {
		let switch_instance_props = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		l(nodes) {
			if (switch_instance) switch_instance.$$.fragment.l(nodes);
			switch_instance_anchor = empty();
		},

		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var switch_instance_changes = changed.props ? get_spread_update(switch_instance_spread_levels, [
				ctx.props
			]) : {};

			if (switch_value !== (switch_value = ctx.Default)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					on_outro(() => {
						old_component.$destroy();
					});
					old_component.$$.fragment.o(1);
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					switch_instance.$$.fragment.i(1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i(local) {
			if (current) return;
			if (switch_instance) switch_instance.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			if (switch_instance) switch_instance.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(switch_instance_anchor);
			}

			if (switch_instance) switch_instance.$destroy(detaching);
		}
	};
}

// (24:0) {#if Component && Component !== Default}
function create_if_block(ctx) {
	var await_block_anchor, promise, current;

	let info = {
		ctx,
		current: null,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 'Result',
		error: 'null',
		blocks: Array(3)
	};

	handle_promise(promise = ctx.Component(), info);

	return {
		c() {
			await_block_anchor = empty();

			info.block.c();
		},

		l(nodes) {
			await_block_anchor = empty();

			info.block.l(nodes);
		},

		m(target, anchor) {
			insert(target, await_block_anchor, anchor);

			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;

			current = true;
		},

		p(changed, new_ctx) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (('Component' in changed) && promise !== (promise = ctx.Component()) && handle_promise(promise, info)) ; else {
				info.block.p(changed, assign(assign({}, ctx), info.resolved));
			}
		},

		i(local) {
			if (current) return;
			info.block.i();
			current = true;
		},

		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				if (block) block.o();
			}

			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(await_block_anchor);
			}

			info.block.d(detaching);
			info = null;
		}
	};
}

// (1:0) <script>   import Loadable from 'svelte-loadable'   import dimensions from '../stores/dimensions'    export let Default   export let Mobile   export let Desktop   export let props    export let widthThreshhold = 500   export let heightThreshhold = null    $: width = $dimensions.width   $: height = $dimensions.height    let Component = Default   $: {     if (widthThreshhold && width < widthThreshhold ) Component = Mobile     else if (heightThreshhold && height < heightThreshhold ) Component = Mobile     else Component = Desktop   }
function create_catch_block(ctx) {
	return {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (27:2) {:then Result}
function create_then_block(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		ctx.props
	];

	var switch_value = ctx.Result.default;

	function switch_props(ctx) {
		let switch_instance_props = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		l(nodes) {
			if (switch_instance) switch_instance.$$.fragment.l(nodes);
			switch_instance_anchor = empty();
		},

		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var switch_instance_changes = changed.props ? get_spread_update(switch_instance_spread_levels, [
				ctx.props
			]) : {};

			if (switch_value !== (switch_value = ctx.Result.default)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					on_outro(() => {
						old_component.$destroy();
					});
					old_component.$$.fragment.o(1);
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					switch_instance.$$.fragment.i(1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i(local) {
			if (current) return;
			if (switch_instance) switch_instance.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			if (switch_instance) switch_instance.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(switch_instance_anchor);
			}

			if (switch_instance) switch_instance.$destroy(detaching);
		}
	};
}

// (25:22)      <svelte:component this={Default}
function create_pending_block(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		ctx.props
	];

	var switch_value = ctx.Default;

	function switch_props(ctx) {
		let switch_instance_props = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		l(nodes) {
			if (switch_instance) switch_instance.$$.fragment.l(nodes);
			switch_instance_anchor = empty();
		},

		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var switch_instance_changes = changed.props ? get_spread_update(switch_instance_spread_levels, [
				ctx.props
			]) : {};

			if (switch_value !== (switch_value = ctx.Default)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					on_outro(() => {
						old_component.$destroy();
					});
					old_component.$$.fragment.o(1);
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					switch_instance.$$.fragment.i(1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i(local) {
			if (current) return;
			if (switch_instance) switch_instance.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			if (switch_instance) switch_instance.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(switch_instance_anchor);
			}

			if (switch_instance) switch_instance.$destroy(detaching);
		}
	};
}

function create_fragment(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.Component && ctx.Component !== ctx.Default) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},

		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				on_outro(() => {
					if_blocks[previous_block_index].d(1);
					if_blocks[previous_block_index] = null;
				});
				if_block.o(1);
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				if_block.i(1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i(local) {
			if (current) return;
			if (if_block) if_block.i();
			current = true;
		},

		o(local) {
			if (if_block) if_block.o();
			current = false;
		},

		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach$1(if_block_anchor);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $dimensions;

	subscribe($$self, dimensions, $$value => { $dimensions = $$value; $$invalidate('$dimensions', $dimensions); });

	

  let { Default, Mobile, Desktop, props, widthThreshhold = 500, heightThreshhold = null } = $$props;

  let Component = Default;

	$$self.$set = $$props => {
		if ('Default' in $$props) $$invalidate('Default', Default = $$props.Default);
		if ('Mobile' in $$props) $$invalidate('Mobile', Mobile = $$props.Mobile);
		if ('Desktop' in $$props) $$invalidate('Desktop', Desktop = $$props.Desktop);
		if ('props' in $$props) $$invalidate('props', props = $$props.props);
		if ('widthThreshhold' in $$props) $$invalidate('widthThreshhold', widthThreshhold = $$props.widthThreshhold);
		if ('heightThreshhold' in $$props) $$invalidate('heightThreshhold', heightThreshhold = $$props.heightThreshhold);
	};

	let width, height;

	$$self.$$.update = ($$dirty = { $dimensions: 1, widthThreshhold: 1, width: 1, Mobile: 1, heightThreshhold: 1, height: 1, Desktop: 1 }) => {
		if ($$dirty.$dimensions) { $$invalidate('width', width = $dimensions.width); }
		if ($$dirty.$dimensions) { $$invalidate('height', height = $dimensions.height); }
		if ($$dirty.widthThreshhold || $$dirty.width || $$dirty.Mobile || $$dirty.heightThreshhold || $$dirty.height || $$dirty.Desktop) { {
        if (widthThreshhold && width < widthThreshhold ) $$invalidate('Component', Component = Mobile);
        else if (heightThreshhold && height < heightThreshhold ) $$invalidate('Component', Component = Mobile);
        else $$invalidate('Component', Component = Desktop);
      } }
	};

	return {
		Default,
		Mobile,
		Desktop,
		props,
		widthThreshhold,
		heightThreshhold,
		Component
	};
}

class DimensionAware extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, ["Default", "Mobile", "Desktop", "props", "widthThreshhold", "heightThreshhold"]);
	}
}

/* src/components/FlatButton.svelte generated by Svelte v3.4.4 */

function create_fragment$1(ctx) {
	var div, button, current, dispose;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			div = element("div");
			button = element("button");

			if (default_slot) default_slot.c();
			this.h();
		},

		l(nodes) {
			div = claim_element(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			button = claim_element(div_nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			if (default_slot) default_slot.l(button_nodes);
			button_nodes.forEach(detach$1);
			div_nodes.forEach(detach$1);
			this.h();
		},

		h() {
			button.className = "button svelte-67owpm";
			dispose = listen(button, "click", ctx.onClick);
		},

		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button);

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i(local) {
			if (current) return;
			if (default_slot && default_slot.i) default_slot.i(local);
			current = true;
		},

		o(local) {
			if (default_slot && default_slot.o) default_slot.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	const dispatch = createEventDispatcher();
  const onClick = () => dispatch('click');

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { onClick, $$slots, $$scope };
}

class FlatButton extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
	}
}

/* src/components/ToolbarMobile.svelte generated by Svelte v3.4.4 */

// (23:2) <FlatButton on:click={onMenu}>
function create_default_slot(ctx) {
	var current;

	var menuicon = new MenuIcon({ props: { alt: "open navigation" } });

	return {
		c() {
			menuicon.$$.fragment.c();
		},

		l(nodes) {
			menuicon.$$.fragment.l(nodes);
		},

		m(target, anchor) {
			mount_component(menuicon, target, anchor);
			current = true;
		},

		p: noop,

		i(local) {
			if (current) return;
			menuicon.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			menuicon.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			menuicon.$destroy(detaching);
		}
	};
}

function create_fragment$2(ctx) {
	var div, current;

	var flatbutton = new FlatButton({
		props: {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	}
	});
	flatbutton.$on("click", ctx.onMenu);

	return {
		c() {
			div = element("div");
			flatbutton.$$.fragment.c();
			this.h();
		},

		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			flatbutton.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach$1);
			this.h();
		},

		h() {
			div.className = "container nav-icon svelte-vbzpg2";
		},

		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(flatbutton, div, null);
			current = true;
		},

		p(changed, ctx) {
			var flatbutton_changes = {};
			if (changed.$$scope) flatbutton_changes.$$scope = { changed, ctx };
			flatbutton.$set(flatbutton_changes);
		},

		i(local) {
			if (current) return;
			flatbutton.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			flatbutton.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			flatbutton.$destroy();
		}
	};
}

function instance$2($$self) {
	

  const dispatch = createEventDispatcher();

  const onMenu = () => dispatch('menu');

	return { onMenu };
}

class ToolbarMobile extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, []);
	}
}

/* src/components/Drawer.svelte generated by Svelte v3.4.4 */

// (9:0) {#if open}
function create_if_block$1(ctx) {
	var div0, t, div1, current, dispose;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			div0 = element("div");
			t = space();
			div1 = element("div");

			if (default_slot) default_slot.c();
			this.h();
		},

		l(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			div0_nodes.forEach(detach$1);
			t = claim_text(nodes, "\n\t");

			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach$1);
			this.h();
		},

		h() {
			div0.className = "overlay mask svelte-1usk1hu";

			div1.className = "overlay container svelte-1usk1hu";
			dispose = listen(div0, "click", ctx.onClose);
		},

		m(target, anchor) {
			insert(target, div0, anchor);
			insert(target, t, anchor);
			insert(target, div1, anchor);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i(local) {
			if (current) return;
			if (default_slot && default_slot.i) default_slot.i(local);
			current = true;
		},

		o(local) {
			if (default_slot && default_slot.o) default_slot.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(div0);
				detach$1(t);
				detach$1(div1);
			}

			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};
}

function create_fragment$3(ctx) {
	var if_block_anchor, current;

	var if_block = (ctx.open) && create_if_block$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			if (ctx.open) {
				if (if_block) {
					if_block.p(changed, ctx);
					if_block.i(1);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.i(1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				on_outro(() => {
					if_block.d(1);
					if_block = null;
				});

				if_block.o(1);
				check_outros();
			}
		},

		i(local) {
			if (current) return;
			if (if_block) if_block.i();
			current = true;
		},

		o(local) {
			if (if_block) if_block.o();
			current = false;
		},

		d(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach$1(if_block_anchor);
			}
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { open = false } = $$props;

  const dispatch = createEventDispatcher();

  const onClose = () => dispatch('close');

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('open' in $$props) $$invalidate('open', open = $$props.open);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { open, onClose, $$slots, $$scope };
}

class Drawer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["open"]);
	}
}

/* src/components/NavMobile.svelte generated by Svelte v3.4.4 */

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.path = list[i].path;
	child_ctx.icon = list[i].icon;
	child_ctx.title = list[i].title;
	return child_ctx;
}

// (16:2) {#each menuRoutes as { path, icon, title }
function create_each_block(key_1, ctx) {
	var a, div0, t0, div1, t1_value = ctx.title, t1, div1_href_value, t2, a_href_value, a_alt_value, current, dispose;

	var switch_value = ctx.icon;

	function switch_props(ctx) {
		return {};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		key: key_1,

		first: null,

		c() {
			a = element("a");
			div0 = element("div");
			if (switch_instance) switch_instance.$$.fragment.c();
			t0 = space();
			div1 = element("div");
			t1 = text(t1_value);
			t2 = space();
			this.h();
		},

		l(nodes) {
			a = claim_element(nodes, "A", { href: true, alt: true, class: true }, false);
			var a_nodes = children(a);

			div0 = claim_element(a_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			if (switch_instance) switch_instance.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach$1);
			t0 = claim_text(a_nodes, "\n\t\t\t\t");

			div1 = claim_element(a_nodes, "DIV", { class: true, href: true }, false);
			var div1_nodes = children(div1);

			t1 = claim_text(div1_nodes, t1_value);
			div1_nodes.forEach(detach$1);
			t2 = claim_text(a_nodes, "\n\t\t\t");
			a_nodes.forEach(detach$1);
			this.h();
		},

		h() {
			div0.className = "item-icon svelte-11qz7r9";
			div1.className = "item-title";
			attr(div1, "href", div1_href_value = ctx.path);
			a.href = a_href_value = ctx.path;
			attr(a, "alt", a_alt_value = ctx.title);
			a.className = "item-container svelte-11qz7r9";
			toggle_class(a, "selected", ctx.segment === ctx.path);
			dispose = listen(a, "click", ctx.toggleMenu);
			this.first = a;
		},

		m(target, anchor) {
			insert(target, a, anchor);
			append(a, div0);

			if (switch_instance) {
				mount_component(switch_instance, div0, null);
			}

			append(a, t0);
			append(a, div1);
			append(div1, t1);
			append(a, t2);
			current = true;
		},

		p(changed, ctx) {
			if (switch_value !== (switch_value = ctx.icon)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					on_outro(() => {
						old_component.$destroy();
					});
					old_component.$$.fragment.o(1);
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					switch_instance.$$.fragment.i(1);
					mount_component(switch_instance, div0, null);
				} else {
					switch_instance = null;
				}
			}

			if ((changed.segment || changed.menuRoutes)) {
				toggle_class(a, "selected", ctx.segment === ctx.path);
			}
		},

		i(local) {
			if (current) return;
			if (switch_instance) switch_instance.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			if (switch_instance) switch_instance.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(a);
			}

			if (switch_instance) switch_instance.$destroy();
			dispose();
		}
	};
}

// (14:0) <Drawer open={menuOpen} on:close={toggleMenu}>
function create_default_slot$1(ctx) {
	var nav, each_blocks = [], each_1_lookup = new Map(), current;

	var each_value = menuRoutes;

	const get_key = ctx => ctx.path;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			nav = element("nav");

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
			this.h();
		},

		l(nodes) {
			nav = claim_element(nodes, "NAV", { class: true }, false);
			var nav_nodes = children(nav);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(nav_nodes);

			nav_nodes.forEach(detach$1);
			this.h();
		},

		h() {
			nav.className = "container svelte-11qz7r9";
		},

		m(target, anchor) {
			insert(target, nav, anchor);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(nav, null);

			current = true;
		},

		p(changed, ctx) {
			const each_value = menuRoutes;

			group_outros();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, nav, outro_and_destroy_block, create_each_block, null, get_each_context);
			check_outros();
		},

		i(local) {
			if (current) return;
			for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

			current = true;
		},

		o(local) {
			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].o();

			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(nav);
			}

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
		}
	};
}

function create_fragment$4(ctx) {
	var t, current;

	var toolbar = new ToolbarMobile({});
	toolbar.$on("menu", ctx.toggleMenu);

	var drawer = new Drawer({
		props: {
		open: ctx.menuOpen,
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	}
	});
	drawer.$on("close", ctx.toggleMenu);

	return {
		c() {
			toolbar.$$.fragment.c();
			t = space();
			drawer.$$.fragment.c();
		},

		l(nodes) {
			toolbar.$$.fragment.l(nodes);
			t = claim_text(nodes, "\n\n");
			drawer.$$.fragment.l(nodes);
		},

		m(target, anchor) {
			mount_component(toolbar, target, anchor);
			insert(target, t, anchor);
			mount_component(drawer, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var drawer_changes = {};
			if (changed.menuOpen) drawer_changes.open = ctx.menuOpen;
			if (changed.$$scope || changed.segment) drawer_changes.$$scope = { changed, ctx };
			drawer.$set(drawer_changes);
		},

		i(local) {
			if (current) return;
			toolbar.$$.fragment.i(local);

			drawer.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			toolbar.$$.fragment.o(local);
			drawer.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			toolbar.$destroy(detaching);

			if (detaching) {
				detach$1(t);
			}

			drawer.$destroy(detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	

	let { segment = '' } = $$props;

	let menuOpen = false;
	const toggleMenu = () => { $$invalidate('menuOpen', menuOpen = !menuOpen); };

	$$self.$set = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
	};

	return { segment, menuOpen, toggleMenu };
}

class NavMobile extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["segment"]);
	}
}

/* src/routes/_layout.svelte generated by Svelte v3.4.4 */

function create_fragment$5(ctx) {
	var t, main, current;

	var dimensionaware = new DimensionAware({
		props: {
		Default: NavMobile,
		Desktop: func,
		props: { segment: ctx.segment }
	}
	});

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			dimensionaware.$$.fragment.c();
			t = space();
			main = element("main");

			if (default_slot) default_slot.c();
			this.h();
		},

		l(nodes) {
			dimensionaware.$$.fragment.l(nodes);
			t = claim_text(nodes, "\n\n");

			main = claim_element(nodes, "MAIN", { class: true }, false);
			var main_nodes = children(main);

			if (default_slot) default_slot.l(main_nodes);
			main_nodes.forEach(detach$1);
			this.h();
		},

		h() {
			main.className = "svelte-1b1evn7";
		},

		m(target, anchor) {
			mount_component(dimensionaware, target, anchor);
			insert(target, t, anchor);
			insert(target, main, anchor);

			if (default_slot) {
				default_slot.m(main, null);
			}

			current = true;
		},

		p(changed, ctx) {
			var dimensionaware_changes = {};
			if (changed.NavMobile) dimensionaware_changes.Default = NavMobile;
			if (changed.segment) dimensionaware_changes.props = { segment: ctx.segment };
			dimensionaware.$set(dimensionaware_changes);

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}
		},

		i(local) {
			if (current) return;
			dimensionaware.$$.fragment.i(local);

			if (default_slot && default_slot.i) default_slot.i(local);
			current = true;
		},

		o(local) {
			dimensionaware.$$.fragment.o(local);
			if (default_slot && default_slot.o) default_slot.o(local);
			current = false;
		},

		d(detaching) {
			dimensionaware.$destroy(detaching);

			if (detaching) {
				detach$1(t);
				detach$1(main);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function func() {
	return import('./NavDesktop.e8e5fc15.js');
}

function instance$5($$self, $$props, $$invalidate) {
	

	let { segment } = $$props;

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { segment, $$slots, $$scope };
}

class Layout extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["segment"]);
	}
}

/* src/routes/_error.svelte generated by Svelte v3.4.4 */

// (38:0) {#if dev && error.stack}
function create_if_block$2(ctx) {
	var pre, t_value = ctx.error.stack, t;

	return {
		c() {
			pre = element("pre");
			t = text(t_value);
		},

		l(nodes) {
			pre = claim_element(nodes, "PRE", {}, false);
			var pre_nodes = children(pre);

			t = claim_text(pre_nodes, t_value);
			pre_nodes.forEach(detach$1);
		},

		m(target, anchor) {
			insert(target, pre, anchor);
			append(pre, t);
		},

		p(changed, ctx) {
			if ((changed.error) && t_value !== (t_value = ctx.error.stack)) {
				set_data(t, t_value);
			}
		},

		d(detaching) {
			if (detaching) {
				detach$1(pre);
			}
		}
	};
}

function create_fragment$6(ctx) {
	var title_value, t0, h1, t1, t2, p, t3_value = ctx.error.message, t3, t4, if_block_anchor;

	document.title = title_value = ctx.status;

	var if_block = (ctx.dev && ctx.error.stack) && create_if_block$2(ctx);

	return {
		c() {
			t0 = space();
			h1 = element("h1");
			t1 = text(ctx.status);
			t2 = space();
			p = element("p");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},

		l(nodes) {
			t0 = claim_text(nodes, "\n\n");

			h1 = claim_element(nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t1 = claim_text(h1_nodes, ctx.status);
			h1_nodes.forEach(detach$1);
			t2 = claim_text(nodes, "\n\n");

			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t3 = claim_text(p_nodes, t3_value);
			p_nodes.forEach(detach$1);
			t4 = claim_text(nodes, "\n\n");
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},

		h() {
			h1.className = "svelte-8od9u6";
			p.className = "svelte-8od9u6";
		},

		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, h1, anchor);
			append(h1, t1);
			insert(target, t2, anchor);
			insert(target, p, anchor);
			append(p, t3);
			insert(target, t4, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},

		p(changed, ctx) {
			if ((changed.status) && title_value !== (title_value = ctx.status)) {
				document.title = title_value;
			}

			if (changed.status) {
				set_data(t1, ctx.status);
			}

			if ((changed.error) && t3_value !== (t3_value = ctx.error.message)) {
				set_data(t3, t3_value);
			}

			if (ctx.dev && ctx.error.stack) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d(detaching) {
			if (detaching) {
				detach$1(t0);
				detach$1(h1);
				detach$1(t2);
				detach$1(p);
				detach$1(t4);
			}

			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach$1(if_block_anchor);
			}
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { status, error } = $$props;

	const dev = undefined === 'development';

	$$self.$set = $$props => {
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
	};

	return { status, error, dev };
}

class Error$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, ["status", "error"]);
	}
}

/* src/node_modules/@sapper/internal/App.svelte generated by Svelte v3.4.4 */

// (21:1) {:else}
function create_else_block$1(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		ctx.level1.props
	];

	var switch_value = ctx.level1.component;

	function switch_props(ctx) {
		let switch_instance_props = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		l(nodes) {
			if (switch_instance) switch_instance.$$.fragment.l(nodes);
			switch_instance_anchor = empty();
		},

		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var switch_instance_changes = changed.level1 ? get_spread_update(switch_instance_spread_levels, [
				ctx.level1.props
			]) : {};

			if (switch_value !== (switch_value = ctx.level1.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					on_outro(() => {
						old_component.$destroy();
					});
					old_component.$$.fragment.o(1);
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					switch_instance.$$.fragment.i(1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i(local) {
			if (current) return;
			if (switch_instance) switch_instance.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			if (switch_instance) switch_instance.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach$1(switch_instance_anchor);
			}

			if (switch_instance) switch_instance.$destroy(detaching);
		}
	};
}

// (19:1) {#if error}
function create_if_block$3(ctx) {
	var current;

	var error_1 = new Error$1({
		props: { error: ctx.error, status: ctx.status }
	});

	return {
		c() {
			error_1.$$.fragment.c();
		},

		l(nodes) {
			error_1.$$.fragment.l(nodes);
		},

		m(target, anchor) {
			mount_component(error_1, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var error_1_changes = {};
			if (changed.error) error_1_changes.error = ctx.error;
			if (changed.status) error_1_changes.status = ctx.status;
			error_1.$set(error_1_changes);
		},

		i(local) {
			if (current) return;
			error_1.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			error_1.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			error_1.$destroy(detaching);
		}
	};
}

// (18:0) <Layout segment="{segments[0]}" {...level0.props}>
function create_default_slot$2(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block$3,
		create_else_block$1
	];

	var if_blocks = [];

	function select_block_type(ctx) {
		if (ctx.error) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},

		l(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				on_outro(() => {
					if_blocks[previous_block_index].d(1);
					if_blocks[previous_block_index] = null;
				});
				if_block.o(1);
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				if_block.i(1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i(local) {
			if (current) return;
			if (if_block) if_block.i();
			current = true;
		},

		o(local) {
			if (if_block) if_block.o();
			current = false;
		},

		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach$1(if_block_anchor);
			}
		}
	};
}

function create_fragment$7(ctx) {
	var current;

	var layout_spread_levels = [
		{ segment: ctx.segments[0] },
		ctx.level0.props
	];

	let layout_props = {
		$$slots: { default: [create_default_slot$2] },
		$$scope: { ctx }
	};
	for (var i = 0; i < layout_spread_levels.length; i += 1) {
		layout_props = assign(layout_props, layout_spread_levels[i]);
	}
	var layout = new Layout({ props: layout_props });

	return {
		c() {
			layout.$$.fragment.c();
		},

		l(nodes) {
			layout.$$.fragment.l(nodes);
		},

		m(target, anchor) {
			mount_component(layout, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			var layout_changes = (changed.segments || changed.level0) ? get_spread_update(layout_spread_levels, [
				(changed.segments) && { segment: ctx.segments[0] },
				(changed.level0) && ctx.level0.props
			]) : {};
			if (changed.$$scope || changed.error || changed.status || changed.level1) layout_changes.$$scope = { changed, ctx };
			layout.$set(layout_changes);
		},

		i(local) {
			if (current) return;
			layout.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			layout.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			layout.$destroy(detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	

	let { stores, error, status, segments, level0, level1 = null } = $$props;

	setContext(CONTEXT_KEY, stores);

	$$self.$set = $$props => {
		if ('stores' in $$props) $$invalidate('stores', stores = $$props.stores);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('segments' in $$props) $$invalidate('segments', segments = $$props.segments);
		if ('level0' in $$props) $$invalidate('level0', level0 = $$props.level0);
		if ('level1' in $$props) $$invalidate('level1', level1 = $$props.level1);
	};

	return {
		stores,
		error,
		status,
		segments,
		level0,
		level1
	};
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, ["stores", "error", "status", "segments", "level0", "level1"]);
	}
}

// This file is generated by Sapper — do not edit it!

const ignore = [/^\/blog.json$/, /^\/blog\/([^\/]+?).json$/];

const components = [
	{
		js: () => import('./index.28b32371.js'),
		css: ["index.28b32371.css"]
	},
	{
		js: () => import('./about.0a87b4d1.js'),
		css: []
	},
	{
		js: () => import('./index.3ada48c2.js'),
		css: ["index.3ada48c2.css"]
	},
	{
		js: () => import('./[slug].4a017ed8.js'),
		css: ["[slug].4a017ed8.css"]
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// about.svelte
		pattern: /^\/about\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// blog/index.svelte
		pattern: /^\/blog\/?$/,
		parts: [
			{ i: 2 }
		]
	},

	{
		// blog/[slug].svelte
		pattern: /^\/blog\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 3, params: match => ({ slug: d(match[1]) }) }
		]
	}
])(decodeURIComponent);

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: writable({}),
	preloading: writable(null),
	session: writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;
function set_prefetching(href, promise) {
	prefetching = { href, promise };
}

let target;
function set_target(element) {
	target = element;
}

let uid = 1;
function set_uid(n) {
	uid = n;
}

let cid;
function set_cid(n) {
	cid = n;
}

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function handle_error(url) {
	const { pathname, search } = location;
	const { session, preloaded, status, error } = initial_data;

	if (!root_preloaded) {
		root_preloaded = preloaded && preloaded[0];
	}

	const props = {
		error,
		status,
		session,
		level0: {
			props: root_preloaded
		},
		level1: {
			props: {
				status,
				error
			},
			component: Error$1
		},
		segments: preloaded

	};
	const query = extract_query(search);
	render(null, [], props, { path: pathname, query, params: {} });
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};

		// first load — remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach(start.nextSibling);
			detach(start);
			detach(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary — once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

function prefetch(href) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		if (!prefetching || href !== prefetching.href) {
			set_prefetching(href, hydrate_target(target));
		}

		return prefetching.promise;
	}
}

function start(opts

) {
	if ('scrollRestoration' in _history) {
		_history.scrollRestoration = 'manual';
	}

	set_target(opts.target);

	addEventListener('click', handle_click);
	addEventListener('popstate', handle_popstate);

	// prefetch
	addEventListener('touchstart', trigger_prefetch);
	addEventListener('mousemove', handle_mousemove);

	return Promise.resolve().then(() => {
		const { hash, href } = location;

		_history.replaceState({ id: uid }, '', href);

		const url = new URL(location.href);

		if (initial_data.error) return handle_error(url);

		const target = select_target(url);
		if (target) return navigate(target, uid, true, hash);
	});
}

let mousemove_timeout;

function handle_mousemove(event) {
	clearTimeout(mousemove_timeout);
	mousemove_timeout = setTimeout(() => {
		trigger_prefetch(event);
	}, 20);
}

function trigger_prefetch(event) {
	const a = find_anchor(event.target);
	if (!a || a.rel !== 'prefetch') return;

	prefetch(a.href);
}

function handle_click(event) {
	// Adapted from https://github.com/visionmedia/page.js
	// MIT license https://github.com/visionmedia/page.js#license
	if (which(event) !== 1) return;
	if (event.metaKey || event.ctrlKey || event.shiftKey) return;
	if (event.defaultPrevented) return;

	const a = find_anchor(event.target);
	if (!a) return;

	if (!a.href) return;

	// check if link is inside an svg
	// in this case, both href and target are always inside an object
	const svg = typeof a.href === 'object' && a.href.constructor.name === 'SVGAnimatedString';
	const href = String(svg ? (a).href.baseVal : a.href);

	if (href === location.href) {
		if (!location.hash) event.preventDefault();
		return;
	}

	// Ignore if tag has
	// 1. 'download' attribute
	// 2. rel='external' attribute
	if (a.hasAttribute('download') || a.getAttribute('rel') === 'external') return;

	// Ignore if <a> has a target
	if (svg ? (a).target.baseVal : a.target) return;

	const url = new URL(href);

	// Don't handle hash changes
	if (url.pathname === location.pathname && url.search === location.search) return;

	const target = select_target(url);
	if (target) {
		const noscroll = a.hasAttribute('sapper-noscroll');
		navigate(target, null, noscroll, url.hash);
		event.preventDefault();
		_history.pushState({ id: cid }, '', url.href);
	}
}

function which(event) {
	return event.which === null ? event.button : event.which;
}

function find_anchor(node) {
	while (node && node.nodeName.toUpperCase() !== 'A') node = node.parentNode; // SVG <a> elements have a lowercase name
	return node;
}

function handle_popstate(event) {
	scroll_history[cid] = scroll_state();

	if (event.state) {
		const url = new URL(location.href);
		const target = select_target(url);
		if (target) {
			navigate(target, event.state.id);
		} else {
			location.href = location.href;
		}
	} else {
		// hashchange
		set_uid(uid + 1);
		set_cid(uid);
		_history.replaceState({ id: cid }, '', location.href);
	}
}

start({
	target: document.querySelector('#sapper')
});
//# sourceMappingURL=client.f823d832.js.map
